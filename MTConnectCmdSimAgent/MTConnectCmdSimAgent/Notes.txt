class=\"histogram\"

http://dlib.net/bayes.html

SSDP is a widely used protocol
•UPnP or DLNA uses it for service discovery
•All networking issues have been solved
•Many open source implementation are free to use
•Multicast based
"						<DataItem type=\"ASSET_CHANGED\" id=\"####asset_partprogram\" category=\"EVENT\" name=\"asset_partprogram\"/>\n"						
"						<DataItem type=\"ASSET_CHANGED\" id=\"####asset_tool\" category=\"EVENT\" name=\"asset_tool\"/>	\n"					

SendToHandlers<CResourceHandler, &CResourceHandler::_statemachine,&CMonitor::ControlThread::SyncEvent> (e);
	template<typename T,  CMonitor * T::*Var, void (StateModel::ControlThread::*Var2)(StateModel::StateType)>
	static void SendToHandlers(std::string e)
	{
		for(int i=0 ; i<CResourceHandler::_rhandlers.size(); i++)
		{
			T * t ( (T *) CResourceHandler::_rhandlers.at(i));
			(t->*Var)->ControlThread::Var2(e);

		}
	}

#if 0
	for(int i=0; i< processes.size(); i++)
	{  
		Cell * cell = FindCell((LPCSTR) processes[i]->cellsRequired[i]);
		CCellHandler * _cellHandler = new CCellHandler(cell);
		_CellResourcesRequired.push_back(_cellHandler);
		for(int k=0; k< cell->resourceIds.size(); k++)
		{
			CResourceHandler *  rh = CResourceHandler::FindHandler((LPCSTR)cell->resourceIds[i]);
			if(rh==NULL)
			{	
				DebugBreak();
			}

			_cellHandler->_ResourceHandlers.push_back(rh);

			// Now find program associated with resource and process
			std::vector<int> programindexes = processes[i]->GetPropertyMatches<0>(cell->resourceIds[i]);
			for(int j=0; j< programindexes.size(); j++)
			{
				std::string program = processes[i]->GetProperty(programindexes[j], 1);
				rh->_programs.push_back(program);

				int duration = ConvertString(processes[i]->GetProperty(programindexes[j], 3),20);
				rh->_estDuration.push_back(duration);
			}
		}
	}
#endif

#if 0
#define IDT_TIMER 0x4B8
static void DoEvents()
{
	bool bRunning=true;
	SetTimer(NULL,IDT_TIMER, 50,(TIMERPROC) NULL);
    MSG msg;
    while (bRunning)
	{
        //if (PeekMessage(&msg, _wndMain->m_hWnd, 0, 0, PM_REMOVE))
        if (GetMessage(&msg, NULL, 0, 0))
		{
			if(msg.message == WM_TIMER)
			{
				KillTimer(_wndMain->m_hWnd, IDT_TIMER);
				bRunning=false;
					// DebugBreak();
			}

            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
		else  bRunning=false;
	}
		::Sleep(10); 
}

#endif



				<PartsProduced>
					<PartType>
						<PartTypeIdentifier>Part2-12345</PartTypeIdentifier>
					</PartType>
					<PartQuantity>1</PartQuantity>
				</PartsProduced>
				<PartsConsumed>
					<PartType>

		// Some MTConnectCmdSim token string dont have the same number of tokens
		//if(tokens.size() < enums["eFEEDRATE_OVERRIDE"])
		//	return FailWithMsg(E_FAIL, StdStringFormat("Token # size too small  for File \"%s\" device %s\n", filename.c_str(),   _device.c_str())) ;

		//if(tokens.size() < _nNumTokens)
		//	return FailWithMsg(E_FAIL, StdStringFormat("Token # size too small  File \"%s\" device %s\n", filename.c_str(),   _device.c_str())) ;
		
		//COleDateTime filedate;
		//if(FAILED(ParseStringDate(tokens[eDAY],filedate)))  // need to get up until first blank space
		//{

		//}
		
			if(!_simulation)
		{
		today =  COleDateTime(now.GetYear(), now.GetMonth(), now.GetDay(), 0, 0, 0);
		}
		else
		{
			today = LastLogDate;
		}
		
		//TODO: Determine what the LPSECURITY_ATTRIBUTES should be.

    		SECURITY_ATTRIBUTES sa;
    		SECURITY_DESCRIPTOR sd;

    		if(!InitializeSecurityDescriptor(&sd,SECURITY_DESCRIPTOR_REVISION)) {
    			DWORD dwLastError = ::GetLastError();
    			LOG4CPLUS_ERROR(m_Logger, "Cannot launch file '" << strFullFilePath << "'.  Failed to initialize security descriptor.  GetLastError=" << dwLastError);
    			return dwLastError;
    		}

    		if(!SetSecurityDescriptorDacl(
    			&sd,	// A pointer to the SECURITY_DESCRIPTOR structure to which the function adds the DACL
    			TRUE,	// presence of a DACL in the security descriptor
    			NULL,	// allows all access to the object
    			FALSE	// DACL has been explicitly specified by a user
    		)) 
    		{
    			DWORD dwLastError = ::GetLastError();
    			LOG4CPLUS_ERROR(m_Logger, "Cannot launch file '" << strFullFilePath << "'.  Failed to set security descriptor DACL.  GetLastError=" << dwLastError);
    			return dwLastError;
    		}

    		if(!SetSecurityDescriptorGroup(
    			&sd,	// A pointer to the SECURITY_DESCRIPTOR structure whose primary group is set by this function
    			NULL,	// no primary group
    			FALSE	// Indicates whether the primary group information was derived from a default mechanism
    		))
    		{
    			DWORD dwLastError = ::GetLastError();
    			LOG4CPLUS_ERROR(m_Logger, "Cannot launch file '" << strFullFilePath << "'.  Failed to set security descriptor primary group.  GetLastError=" << dwLastError);
    			return dwLastError;
    		}

    		if(!SetSecurityDescriptorOwner(
    			&sd,	// A pointer to the SECURITY_DESCRIPTOR structure whose owner is set by this function.
    			NULL,	// If this parameter is NULL, the function clears the security descriptor's owner information. This marks the security descriptor as having no owner.
    			FALSE	// Indicates whether the owner information is derived from a default mechanism.
    		))
    		{
    			DWORD dwLastError = ::GetLastError();
    			LOG4CPLUS_ERROR(m_Logger, "Cannot launch file '" << strFullFilePath << "'.  Failed to set security descriptor owner information.  GetLastError=" << dwLastError);
    			return dwLastError;
    		}

    		if(!SetSecurityDescriptorSacl(
    			&sd,	// A pointer to the SECURITY_DESCRIPTOR structure to which the function adds the SACL
    			FALSE,	// the security descriptor does not contain a SACL
    			NULL,	// security descriptor has a NULL SACL
    			FALSE	// A pointer to a flag that is set to the value of the SE_SACL_DEFAULTED flag in the SECURITY_DESCRIPTOR_CONTROL structure if a SACL exists for the security descriptor
    		))
    		{
    			DWORD dwLastError = ::GetLastError();
    			LOG4CPLUS_ERROR(m_Logger, "Cannot launch file '" << strFullFilePath << "'.  Failed to set security descriptor SACL.  GetLastError=" << dwLastError);
    			return dwLastError;
    		}

    		sa.nLength = sizeof(SECURITY_ATTRIBUTES);
    		sa.lpSecurityDescriptor = &sd;
    		sa.bInheritHandle = TRUE;

			HANDLE hFile = ::CreateFile(strTempFile.c_str(), GENERIC_WRITE, dwShareMode, &sa, CREATE_NEW, dwFlagsAndAttributes, NULL);
			/////////////////////////////////////////////////////////?????????????????????????
			BYTE sd[SECURITY_DESCRIPTOR_MIN_LEN­GTH];

			SECURITY_ATTRIBUTES sa;


			sa.nLength = sizeof(sa);
			sa.bInheritHandle = TRUE; // Whatever you need
			sa.lpSecurityDescriptor = &sd;


			InitializeSecurityDescriptor(&­sd, SECURITY_DESCRIPTOR_REVISION);
			SetSecurityDescriptorDacl(&sd, TRUE, NULL, FALSE); 


			==================================================
		// Day
		// Time
		// AM/PM
		// CONNECTED
		//AUTO      = 0: MDI,       1: MEM,                 3: EDT,    4: HAND,   5: JOG, 10: TAPE
		//RUN       = 0: NOT READY, 1: M-READY, 2: C-START, 3: F-HOLD, 4: B-STOP
		//MOTION    = 0: *** 1: CMTN, 2: CDWL 
		//CMTN Move command is being executed in automatic operation mode.
		//CDWL Dwell is being executed.
		//MSTB      = 0: ****, 1: CFIN
		//EMERGENCY
		//ALARM     = 0: **** (Not emergency) 1: ALARM 2: BATTERY LOW
		//MANUAL
		//EDIT      = 0: **** (Not editing), 1: EDITING, 2: SEARCH (during searching), 3: RESTART (during restart), 4: RETRACE (during retrace) 
		//WRITE
		//LABEL_SKIP
		//WARNING
		//BATTERY
		//MAIN_PROGRAM_O_NUMBER
		//MAIN_PROGRAM_NAME
		//EXEC_O_NUMBER
		//FEEDRATE_OVERRIDE
		//RAPID_OVERRIDE
		//CNC_ALARM_COUNT
		//PMC_ALARM_COUNT
		//PROGRAM_STOP_M00
		//OPTIONAL_STOP_M01
		//25


BY_HANDLE_FILE_INFORMATION fInfo = {0};
GetFileInformationByHandle(hFile, &fInfo);
if(fInfo.dwFileAttributes && FILE_FLAG_DELETE_ON_CLOSE)
{
    std::cout << "Attributes say this file is deleted." << std::endl;
}


sc create Agent  binPath="MTConnectCmdSimAgent.exe"

cd /d %~dp0
cacls . /t  /c  /GRANT Everyone:F
pause

"								<DataItem type=\"SPINDLE_SPEED\" id=\"M1cso1\" category=\"SAMPLE\" name=\"Sovr\" subType=\"OVERRIDE\" units=\"PERCENT\" nativeUnits=\"PERCENT\"/>\n"

sc.exe create Agent  binPath= 

sc.exe stop Agent
sc.exe delete Agent

Remove trailing \n
	//std::string msg = (errmsg.rfind("\n") != std::string::npos) ? errmsg.substr(0,errmsg.size()-1) : errmsg;

Last time File was modified:
#include <sys/stat.h>
	
#include <unistd.h>	
#include <time.h>
	
struct tm* clock;				// create a time structure	
struct stat attrib;			// create a file attribute structure        
stat("afile.txt", &attrib);		// get the attributes of afile.txt	
clock = gmtime(&(attrib.st_mtime));
---------------------
CFile::GetStatus(CFileStatus &rStatus)

CFileStatus structure components


CTime m_ctime - creation
CTime m_mtime - last modification
CTime m_atime - last accessed
long m_size - logical size in bytes
byte m_attribute - attribute byte of the file
char m_szFullName[_MaxSize] absolute filename

/////////////////////////////////////////////
ULONGLONG GetFileSizeEx( CString strPath )
{  
   WIN32_FIND_Data FindData = { 0 };
   //gets a file search handle
   HANDLE hFirstFile = FindFirstFile( strPath, &FindData );  
  
   //if the handle is valid
   if( hFirstFile != INVALID_HANDLE_VALUE )
   {
      //closes the file search handle
      FindClose( hFirstFile );
     
      ULONGLONG FileSize = FindData.nFileSizeHigh;
      FileSize <<= sizeof( FindData.nFileSizeHigh ) * 8; // Push by count of bits
      FileSize |= FindData.nFileSizeLow;
     
      return FileSize;
   }
  
   return 0; // File not found
}



		std::vector<std::string> keys = config.getkeys(tagdefs);
		if(tags.size() < 1 || keys.size() < 1 )
			throw std::exception(StdStringFormat("Error: No [%s] Section or Keys?\n", tagdefs.c_str()).c_str());

		for(int i=0; i<keys.size(); i++)
		{
			Item * item = new Item();
			item->_alias=keys[i];

			// make sure its is an OPC Tag
			if(item->_alias.find(_T("Tag.")) == 0)
			{
				item->_alias=ReplaceOnce(item->_alias, _T("Tag."), _T(""));
				item->vt=VT_BSTR;
			}
			if(item->_alias.find(_T("Enum."))==0)
			{
				item->_type=_T("Enum");
				item->_subtype="Enumeration";
				item->_value=item->_lastvalue= config.GetSymbolValue(tagdefs+"."+ keys[i]).c_str();
				//item->_tagname No tagname
				items.push_back(item);
				continue;
			}
			else if(item->_alias.find(_T("Const."))==0)
			{
				item->_alias=ReplaceOnce(item->_alias,_T("Const."), _T(""));
				item->vt= VT_USERDEFINED;
				item->_subtype="Constant";
			}

			// THese must be DDE lookup
			if(item->_alias.find(_T("Sample."))==0)
			{
				item->_alias=ReplaceOnce(item->_alias,_T("Sample."), _T(""));
				item->_type=_T("Sample");
			}
			else if(item->_alias.find(_T("Event."))==0)
			{
				item->_alias=ReplaceOnce(item->_alias,_T("Event."), _T(""));
				item->_type=_T("Event");
			}
			else if(item->_alias.find(_T("DDE."))==0)  // reads opc values does not send to MT Connect
			{
				item->_alias=ReplaceOnce(item->_alias, _T("DDE."), _T(""));  // OPC value for scripting
				item->_type=_T("DDE");
			}
			else if(item->_alias.find(_T("Condition."))==0)
			{
				item->_alias=ReplaceOnce(item->_alias,_T("Condition."), _T(""));
				item->_type="Condition";
			}
			std::string tmp= config.GetSymbolValue(tagdefs+"."+ keys[i]).c_str();
			item->_tagname=tmp;
			items.push_back(item);
		}
		for(int i = 0 ; i < items.size(); i++)
		{
			//if(items[i]->_type==_T("Event") || items[i]->_type==_T("Sample"))
			//	items[i]->_event= new Event(items[i]->_tagname.c_str());
		}

		// SLOW SLOW SLOW
		//std::string contents;
		//ReadFile(::ExeDirectory()+"ProductionLog.csv",contents);
		//std::vector<std::string> lines = TrimmedTokenize(contents,"\n");
		/*for(int i=0; i< lines.size(); i++)
		{
			std::vector<std::string> tokens = TrimmedTokenize(lines[i],";");
			COleDateTime timestamp;
			if(tokens.size()<=0)
				continue;
			timestamp=GetDateTime(tokens[0]);
			timestamp=COleDateTime(timestamp.GetYear(), timestamp.GetMonth(), timestamp.GetDay(), 0, 0, 0);
			if(timestamp == today)
			{
				for(int j=1; j< tokens.size(); j++);
			}
		}*/


			//// Read and skip lines till current day
			//while ( getline(data,line) )
			//{
			//	COleDateTime timestamp=GetDateTime(line.c_str());
			//	timestamp=COleDateTime(timestamp.GetYear(), timestamp.GetMonth(), timestamp.GetDay(), 0, 0, 0);
			//	if(timestamp == today)
			//	{
			//		break;
			//	}
			//}

	
	
	#if 0
		HANDLE hFile = CreateFile(filename.c_str(),
                          GENERIC_READ, // access (read) mode
                          FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE, // share mode
                          NULL, // pointer to security attributes
                          OPEN_EXISTING, // how to create
                          FILE_ATTRIBUTE_NORMAL,// file attributes
                          NULL); // handle to file with attributes to copy
		if (hFile == INVALID_HANDLE_VALUE)    // did we succeed?
		{
			// possibly call GetLastError() to get a hint what failed
			// and terminate (it is useless to continue if we can’t connect to Direct I/O)
		}
		BY_HANDLE_FILE_INFORMATION fInfo = {0};
		GetFileInformationByHandle(hFile, &fInfo);
		DWORD dwRead = (fInfo.nFileSizeHigh * (MAXDWORD+1)) + fInfo.nFileIndexLow;
		DWORD dwNewSize;
		void * readBuffer = malloc(dwRead);
		// read the original file byte in the buffer
		ReadFile(hFile, readBuffer, dwRead, &dwNewSize, NULL );

		HANDLE hNewFile = CreateFile( tofilename.c_str(), 
			GENERIC_WRITE, 
			 FILE_SHARE_READ|FILE_SHARE_WRITE, 
			NULL, 
			CREATE_ALWAYS, 
			FILE_ATTRIBUTE_NORMAL,
			NULL );
		// write this buffer to the new file
		DWORD dwWritten;
		WriteFile( hNewFile, readBuffer, dwNewSize, &dwWritten, NULL );
		free readBuffer;
#endif

	//fseek(stream, 0, SEEK_END);
		//size_t fileSize = ftell(stream);
		//rewind(stream);
		//char *data = (char*) calloc(sizeof(char), fileSize + 20); // free(data);
		//fseek(stream, 0, SEEK_END);
		//size_t fileSize = ftell(stream);
		//rewind(stream);
		//char *data = (char*) calloc(sizeof(char), fileSize + 20); // free(data);


			#if 0
		//CopyFileEx(filename.c_str(), tofilename.c_str(), NULL/*callback ptr*/, NULL, FALSE, COPY_FILE_OPEN_SOURCE_FOR_WRITE);
		//CopyFile(filename.c_str(), tofilename.c_str(), false);
		std::ifstream in(tofilename, std::ios::in | std::ios::binary);
		if (!in.is_open())
		{
			DebugMessage(StdStringFormat("Local File could not open for device %s\n", _device.c_str()));
			return E_FAIL;
		}
		std::vector<std::string> lines;
		std:: string line;
		if(filesize==_lastfilesize && _lastfilesize != 0 )
			return S_OK; // No new events

		if(filesize>_lastfilesize && _lastfilesize != 0 )
		{	
			// Skip file until new lines
			in.seekg(_lastfilesize);			
		}
		else
		{
			// Read and skip lines till current day
			while ( getline (in,line) )
			{
				COleDateTime timestamp=GetDateTime(line);
				timestamp=COleDateTime(timestamp.GetYear(), timestamp.GetMonth(), timestamp.GetDay(), 0, 0, 0);
				if(timestamp == today)
				{
					break;
				}
			}
		}
		while ( getline (in,line) )
			lines.push_back(line);
#endif


	/*	while ((numread= fread( pAddr, 1, ulFileSize, stream )) < ulFileSize)
		{
			if(numread==0)
			{
				DebugMessage(StdStringFormat("numread File %s is zero for device %s\n", filename.c_str(), _device.c_str()));
				return E_FAIL;
			}
			pAddr = &data[numread];
			ulFileSize-=numread;
		}*/
	//update:
//		for(int i = 0 ; i < items.size(); i++)
//		{
//			if(items[i]->_type==_T("Event") || items[i]->_type==_T("Sample"))
//			{
//				if(items[i]->_value != items[i]->_lastvalue)
//				{
//					this->SetMTCTagValue(items[i]->_tagname,items[i]->_value);
//					items[i]->_lastvalue=items[i]->_value;
//				}
//			}
//		}




		////////////////////////////////////////////////////////////////////
	bool ResetAtMidnite();
	CWorkerThread<> _resetthread;
	struct CResetThread : public IWorkerThreadClient
	{
		HRESULT Execute(DWORD_PTR dwParam, HANDLE hObject);
		HRESULT CloseHandle(HANDLE){ ::CloseHandle(_hTimer); return S_OK; }
		HANDLE _hTimer;
	} _ResetThread;

bool AgentConfigurationEx::ResetAtMidnite()
{
	COleDateTime now = COleDateTime::GetCurrentTime();
	COleDateTime date2 =  COleDateTime(now.GetYear(), now.GetMonth(), now.GetDay(), 0, 0, 0) +  COleDateTimeSpan(1, 0, 0, 1);
	//COleDateTime date2 =  now +  COleDateTimeSpan(0, 0, 2, 0); // testing reset time - 2 minutes
	COleDateTimeSpan tilmidnight = date2-now;
	_resetthread.Initialize();
	_resetthread.AddTimer(
		(long) tilmidnight.GetTotalSeconds() * 1000,
		&_ResetThread,
		(DWORD_PTR) this,
		&_ResetThread._hTimer  // stored newly created timer handle
		) ;
	return true;

}
HRESULT AgentConfigurationEx::CResetThread::Execute(DWORD_PTR dwParam, HANDLE hObject)
{
	static char name[] = "CResetThread::Execute";

	AgentConfigurationEx * agent = (AgentConfigurationEx*) dwParam;
	CancelWaitableTimer(hObject);
	//DebugBreak();

	try {

		PROCESS_INFORMATION pi;
		ZeroMemory( &pi, sizeof(pi) );

		STARTUPINFO si;
		ZeroMemory( &si, sizeof(si) );
		si.cb = sizeof(si);
		si.dwFlags = STARTF_USESHOWWINDOW;
		si.wShowWindow = SW_HIDE;	 // set the window display to HIDE	

		// SCM reset command of this service 
		std::string cmd = StdStringFormat("cmd /c net stop \"%s\" & net start \"%s\"", Globals.ServerName.c_str(), Globals.ServerName.c_str());        // Command line

		if(!::CreateProcess( NULL,   // No module name (use command line)
			const_cast<char *>(cmd.c_str()),
			NULL,           // Process handle not inheritable
			NULL,           // Thread handle not inheritable
			FALSE,          // Set handle inheritance to FALSE
			0,              // No creation flags
			NULL,           // Use parent's environment block
			NULL,           // Use parent's starting directory 
			&si,            // Pointer to STARTUPINFO structure
			&pi ))           // Pointer to PROCESS_INFORMATION structure
			AtlTrace("CreateProcess FAIL ") ;

		::Sleep(5000); // make sure process has spawned before killing thread
	}
	catch(...)
	{
		agent->AbortMsg("Exception  - ResetAtMidnightThread(void *oObject");
	}
	return S_OK;
}


//int main(int aArgc, const char *aArgv[])
//{
//#ifdef _WINDOWS
//	_set_se_translator( trans_func );   //Handles Win32 exceptions (C structured exceptions) as C++ typed exceptions
//	// MICHALOSKI ADDED
//	TCHAR buf[1000];
//	GetModuleFileName(NULL, buf, 1000);
//	std::string path(buf);
//	path=path.substr( 0, path.find_last_of( '\\' ) +1 );
//	SetCurrentDirectory(path.c_str());
//#endif
//	AgentConfigurationEx config;
//	config.setAgent(new AgentEx());
//
//
//	Adapter::enummapping["execution.READY"]="IDLE";
//	Adapter::enummapping["execution.ACTIVE"]="EXECUTING";
//	Adapter::enummapping["execution.INTERRUPTED"]="PAUSED";
//	Adapter::enummapping["execution.STOPPED"]="PAUSED";
//	Adapter::keymapping["mode"]="controllermode";
//	Adapter::keymapping["Fovr"]="path_feedrateovr";
//	Adapter::keymapping["Fact"]="path_feedratefrt";
//
//
//	return config.main(aArgc, (const char **) aArgv);
//}


double  CMonitor::Speedup()
{
	OutputDebugString(StdStringFormat("CMonitor::Speedup() %s\n",Name().c_str()).c_str());
	double dSpeedup=99999.0;
	if(this->GetStateName() == "faulted" ) 
	{
		if(_mttr > 0 && MTBF>0)
			dSpeedup=_mttr;
	}
	else if(GetStateName() == "running"   )
	{
		if(_mtbf>0 && MTBF>0) 
			dSpeedup=_mtbf;
		if( Current()  != NULL && Current()->_mttp != 0.0) 
			dSpeedup=MIN(dSpeedup, Current()->_mttp);
	}
	else if(GetStateName() == "blocked" || GetStateName() == "starved")
	{
		dSpeedup=100000.0;
		return dSpeedup;
	}
	return dSpeedup;
}
	//MSXML2::IXMLDOMDocument2Ptr        m_pXMLDoc;

	//void Clear()
	//{
	//	for(int i=0; i< IObject::GetAllObjects().size(); i++)
	//		IObject::GetAllObjects()[i]->clear();
	//}

	//////////////////////////////////////////////////////
	//std::string GenerateSchema(std::string schema) ;
	//std::string  GenerateTableData(std::string schema) ;
	//SQLHANDLE hConn ;
	//SQLHANDLE hEnv ;
	//HRESULT OpenSqlDatabase(std::string dbname="CMSD");
	//void LoadCMSDFromSql();
	//std::string GetData(SQLHSTMT  hStmt, int j);
	//std::map<std::string,PropertyElement> _sqlProperties;
	//void GetAllProperties();
	//HRESULT CloseSqlDatabase();




//void CWorkOrders::CreateResourcesByJobs(CFactoryIntegrator * factory)
//{
//	static std::string fcnname="CResourceHandlers::CreateResourcesByPart(CFactoryIntegrator * factory) ";
//	this->clear();
//	for(int k=0 ; k< factory->workorders->size(); k++)
//	{
//		ATLASSERT (factory->workorders->at(k)!=NULL);
//		Job * workorder = (Job *) factory->workorders->at(k);
//		for(int i=0 ; i< workorder->partIds.size(); i++)
//		{
//			std::string partid = workorder->partIds[i];
//			Stats stat;
//			try {
//				// Find all resource and then MTP for each resource to make part
//				Part * part = DOCHECK(factory->FindPartById(partid.c_str()),"Bad part lookup") ;
//				ProcessPlan * processplan  =  DOCHECK(factory->FindProcessPlanById(part->processplanidentifier), "Bad processplan ");
//				for(int j=0;j< 	processplan->processes.size(); j++)
//				{
//					Process *process = processplan->processes[j];
//					Cell * cell= DOCHECK(factory->FindCellById((LPCSTR)  process->resourcesRequired[0]), "Bad cell lookup ");
//					CCellHandler * cellHandler = new CCellHandler(cell, factory);
//					_cells.push_back(cellHandler);
//					for(int k=0; k< cell->resourceIds.size(); k++)
//					{
//						Resource * r = DOCHECK(factory->FindResourceById((LPCSTR) cell->resourceIds[k]), "Bad Resource lookup ");
//						std::string name = (LPCSTR) r->name;
//						if(name.empty() || name == "None")  // something wrong
//							name=r->identifier; 
//
//						CResourceHandler * resourceHandler = new CResourceHandler(r, factory);
//						resourceHandler->_identifier = (LPCSTR) r->identifier;
//						resourceHandler->_statemachine->SetStateMachineName(name);
//						_resources.push_back(resourceHandler);
//					}
//				}
//				_resourceByPartStats[partid]=_resources;
//			} 
//			catch(std::exception err) 
//			{ 
//				DebugBreak();
//				OutputDebugString(err.what()); 
//			} 
//		}
//	}
//}

	//// Each processplan contains cell to do work, cell can have one or more resources per cell
	//for(int i=0; i < processplan->processes.size(); i++)
	//{
	//	_ProcessPlanId.push_back(  (LPCSTR) processplan->identifier );
	//	
	//	Process * process =  processplan->processes[i];
	//	_CellResourceRequired.push_back((LPCSTR)  process->resourcesRequired[0]);
	//	Cell * cell= _factory->FindCellById((LPCSTR)  process->resourcesRequired[0]);
	//	//str<<	"     Resource        " << i <<  "  " <<  currentcell[i]  << std::endl;
	//	if(cell!= NULL)
	//	{
	//		//_ResourceRequired.push_back((LPCSTR) cell->resourceIds[0]);
	//		Resource * r = factory->FindResourceById((LPCSTR) cell->resourceIds[0]);
	//		_ResourceRequired.push_back((LPCSTR) r->name);
	//	}

	//// Each processplan contains cell to do work, cell can have one or more resources per cell
	//for(int i=0; i < processplan->processes.size(); i++)
	//{
	//	_ProcessPlanId.push_back(  (LPCSTR) processplan->identifier );
	//	
	//	Process * process =  processplan->processes[i];
	//	_CellResourceRequired.push_back((LPCSTR)  process->resourcesRequired[0]);
	//	Cell * cell= Factory.FindCellById((LPCSTR)  process->resourcesRequired[0]);
	//	//str<<	"     Resource        " << i <<  "  " <<  currentcell[i]  << std::endl;
	//	if(cell!= NULL)
	//	{
	//		//_ResourceRequired.push_back((LPCSTR) cell->resourceIds[0]);
	//		Resource * r = factory->FindResourceById((LPCSTR) cell->resourceIds[0]);
	//		_ResourceRequired.push_back((LPCSTR) r->name);
	//	}


	//}


void CWorkOrders::Run(CWorkOrders * workorders)
{
	//MaxQueueSize=2;
	_jobid=0;
	m_bRunning=true;
	serviceTime.Start();
	m_Thread = boost::thread(&CWorkOrders::process, this, workorders);

}

/** 
* THis class workorder commands processes each workorder in its list. The method process restarts the control thread timer
* and checks for new workorder orders to process. Then the workorder queue is updated to see if any workorders are done, and should be
* removed from the active list. THen each factory resource handler state machine is updated.
*/
void CWorkOrders::process(CWorkOrders * workorders)
{

	_dUpdateRateSec=0.0;
	double _dSpeedupRateSec=0.0;
	while(m_bRunning)
	{
		ControlThread::RestartTimer();
		//if(!_wndMain->_bFinish)
		Newworkorder();               // done with workorder - start new work order
		Update() ;					// update workorder queues 

		//Reporting::AgentStatus(this, JobStatus, Jobs, DeviceStatus );
		FactoryHandlers.UpdateResourceHandlers();  // update state machine
		if(AllFinished())
			break;
		::Sleep(2000);
	}
	serviceTime.Stop();
	//Reporting::GenerateHtmlReport(this, ::ExeDirectory() + "Doc.html" );

#if 0
	boost::mutex::scoped_lock lock(_wndMain->_access);

	_dUpdateRateSec=0.0;
	double _dSpeedupRateSec=0.0;
	while(m_bRunning)
	{
		ControlThread::RestartTimer();
		//if(!_wndMain->_bFinish)
		Newworkorder();               // done with workorder - start new work order
		Update() ;					// update workorder queues 

		double dSpeedup =1.0;
		ControlThread::_dSpeedup=1.0;
		//if(_wndMain->_bZip==true)
		{
			dSpeedup =10000.0;
			for(int i=0 ; i<FactoryHandlers.size(); i++)
			{
				double dUp = FactoryHandlers[i]->_statemachine->Speedup();
				dSpeedup = MIN(dSpeedup,dUp);
				if(dSpeedup < 0)
				{
					OutputDebugString(StdStringFormat("Calamity neg uptime %s=%8.2f\n", FactoryHandlers[i]->_statemachine->Name().c_str(), dUp).c_str());
					DebugBreak();
					FactoryHandlers[i]->_statemachine->Speedup();
				}
			}
			if(dSpeedup == 10000.0) dSpeedup=1.0;
			if(dSpeedup <= 0.0) dSpeedup=1.0;
			ControlThread::_dSpeedup=dSpeedup;
			//OutputDebugString(StdStringFormat("\n Final Speed up %8.2f\n", dSpeedup).c_str());
		}


		_dUpdateRateSec+= 1.0 * ControlThread::_dSpeedup; // one seconds times speed up
		CTimestamp::UpdateSimElapsed(ControlThread::_dSpeedup);// updating time

		FactoryHandlers.UpdateResourceHandlers();  // update state machine

		boost::thread::yield();

		Reporting::AgentStatus(this, JobStatus, Jobs, DeviceStatus );

		if( (_dUpdateRateSec ) <= _dDeadline)
		{
			::SendMessage(_wndMain->m_hWnd, WM_COMMAND, DISPLAY_MSG,0);
			DoEvents();
		}
		else
		{
			_wndMain->cond.wait(lock);
			::SendMessage(_wndMain->m_hWnd, WM_COMMAND, DISPLAY_MSG,0);
		}

		// Stop - break while loop
		if(_wndMain->_bStopped==true)
			break;
		// Pause until woken up by step or resume
		if(_wndMain->_bPaused==true)
		{
			_wndMain->cond.wait(lock);
			::SendMessage(_wndMain->m_hWnd, WM_COMMAND, DISPLAY_MSG,0);
		}
		//// Create snapshot of operation
		//if(_wndMain->_bSnapshot==true)
		//{
		//	_wndMain->_bSnapshot=false;
		//	Reporting::GenerateHtmlReport(this, ::ExeDirectory() + "Doc.html");
		//	::SendMessage(_wndMain->m_hWnd, DISPLAY_SNAPSHOT,0,0);
		//	::Sleep(500);
		//}
		// Create KPI snapshot of operation
		if(_wndMain->_bKPISnapshot==true)
		{
			_wndMain->_bKPISnapshot=false;
			KPI kpi(stats);
			std::string kpiReport = CHtmlTable::CreateHtmlSytlesheetFrontEnd("KPI Precision Sand Casting Saginaw MI")+"</HEAD>";
			kpiReport += kpi.ByResources(stats);
			kpiReport += "</BODY></HTML>\n";

			::WriteFile(::ExeDirectory() + "JobsKpi.html", kpiReport);
			::SendMessage(_wndMain->m_hWnd, DISPLAY_KPISNAPSHOT,0,0);
			::Sleep(500);

		}
		if(AllFinished())
			break;
		if(_wndMain->_bFinish)
		{
			if(size() == 0) // quit when all the current workorders are done
				break;
		}
	}

	//for(int i=0 ; i<_resourceHandlers->size(); i++)
	//{
	//	std::string tmp = _resourceHandlers->at(i)->_statemachine->GenerateReport();
	//	OutputDebugString(StdStringFormat("Resource(%s) Report=%s\n",_resourceHandlers->at(i)->_identifier.c_str(), tmp.c_str() ).c_str())  ;
	//}

	//std::map<std::string,double> states;
	//for(int i=0;i<_resourceHandlers->size() ; i++)
	//	_resourceHandlers->at(i)->_statemachine->GenerateStateReport(states );

	serviceTime.Stop();
	Reporting::GenerateHtmlReport(this, ::ExeDirectory() + "Doc.html" );
#endif
}


_resourceHandler->_statemachine->ControlThread::Cycle() elapsed=    3312
cycledatum= _parser.ReadStream(agentip()+"/"+statusdevice()) elapsed=    1546
Preprocess() elapsed=    1783
Device - CNC1_RESOURCE Command = RESET ComandNum 1:0
_resourceHandler->_statemachine->ControlThread::Cycle() elapsed=    2133
Device - CNC2_RESOURCE Command = RESET ComandNum 1:0
cycledatum= _parser.ReadStream(agentip()+"/"+statusdevice()) elapsed=    1830
Preprocess() elapsed=    2537
_resourceHandler->_statemachine->ControlThread::Cycle() elapsed=    2693
The thread 'Win64 Thread' (0x18ac) has exited with code 0 (0x0).
cycledatum= _parser.ReadStream(agentip()+"/"+statusdevice()) elapsed=    2397
Preprocess() elapsed=    2951
_resourceHandler->_statemachine->ControlThread::Cycle() elapsed=    3143
Device - CNC3Old_RESOURCE Command = RESET ComandNum 1:0
cycledatum= _parser.ReadStream(agentip()+"/"+statusdevice()) elapsed=    2617
Preprocess() elapsed=    3197
_resourceHandler->_statemachine->ControlThread::Cycle() elapsed=    3339

cycledatum= _parser.ReadStream(agentip()+"/"+statusdevice()) elapsed=    3876
Preprocess() elapsed=    4515
_resourceHandler->_statemachine->ControlThread::Cycle() elapsed=    4606
cycledatum= _parser.ReadStream(agentip()+"/"+statusdevice()) elapsed=    3813
Preprocess() elapsed=    4538
_resourceHandler->_statemachine->ControlThread::Cycle() elapsed=    4738
cycledatum= _parser.ReadStream(agentip()+"/"+statusdevice()) elapsed=    3845
Preprocess() elapsed=    4646
_resourceHandler->_statemachine->ControlThread::Cycle() elapsed=    4934
cycledatum= _parser.ReadStream(agentip()+"/"+statusdevice()) elapsed=    5703
Preprocess() elapsed=    6499
_resourceHandler->_statemachine->ControlThread::Cycle() elapsed=    6706
cycledatum= _parser.ReadStream(agentip()+"/"+statusdevice()) elapsed=    6913
Preprocess() elapsed=    9191
_resourceHandler->_statemachine->ControlThread::Cycle() elapsed=    9480




bFlag=ParseXMLDocument(_devicesfilename.c_str()).empty() elapsed=    1209
data=ParseDataItems() elapsed=     518
bFlag=ParseXMLDocument(_devicesfilename.c_str()).empty() elapsed=     844
data=ParseDataItems() elapsed=     627
bFlag=ParseXMLDocument(_devicesfilename.c_str()).empty() elapsed=     749
data=ParseDataItems() elapsed=     338
cycledatum= _parser.ReadStream(agentip()+"/"+statusdevice()) elapsed=    2545
Preprocess() elapsed=    2979
_resourceHandler->_statemachine->ControlThread::Cycle() elapsed=    3116
bFlag=ParseXMLDocument(_devicesfilename.c_str()).empty() elapsed=     708
data=ParseDataItems() elapsed=     309
Device - CNC4_RESOURCE Command = RESET ComandNum 2:1
bFlag=ParseXMLDocument(_devicesfilename.c_str()).empty() elapsed=     538
data=ParseDataItems() elapsed=     409
cycledatum= _parser.ReadStream(agentip()+"/"+statusdevice()) elapsed=    1578
Preprocess() elapsed=    1979
_resourceHandler->_statemachine->ControlThread::Cycle() elapsed=    2052
bFlag=ParseXMLDocument(_devicesfilename.c_str()).empty() elapsed=    1181
data=ParseDataItems() elapsed=     584
bFlag=ParseXMLDocument(_devicesfilename.c_str()).empty() elapsed=    1082
data=ParseDataItems() elapsed=     525
bFlag=ParseXMLDocument(_devicesfilename.c_str()).empty() elapsed=     870
data=ParseDataItems() elapsed=     849
bFlag=ParseXMLDocument(_devicesfilename.c_str()).empty() elapsed=     549
data=ParseDataItems() elapsed=     392
cycledatum= _parser.ReadStream(agentip()+"/"+statusdevice()) elapsed=    5798
Preprocess() elapsed=    6430
_resourceHandler->_statemachine->ControlThread::Cycle() elapsed=    6622
bFlag=ParseXMLDocument(_devicesfilename.c_str()).empty() elapsed=     933
data=ParseDataItems() elapsed=     295
bFlag=ParseXMLDocument(_devicesfilename.c_str()).empty() elapsed=     581
data=ParseDataItems() elapsed=     598
bFlag=ParseXMLDocument(_devicesfilename.c_str()).empty() elapsed=    1019
data=ParseDataItems() elapsed=     655
bFlag=ParseXMLDocument(_devicesfilename.c_str()).empty() elapsed=    1228
data=ParseDataItems() elapsed=    1090
cycledatum= _parser.ReadStream(agentip()+"/"+statusdevice()) elapsed=    5835
Preprocess() elapsed=    6777
_resourceHandler->_statemachine->ControlThread::Cycle() elapsed=    7019
bFlag=ParseXMLDocument(_devicesfilename.c_str()).empty() elapsed=    1335
data=ParseDataItems() elapsed=     361
bFlag=ParseXMLDocument(_devicesfilename.c_str()).empty() elapsed=     740
data=ParseDataItems() elapsed=     500
cycledatum= _parser.ReadStream(agentip()+"/"+statusdevice()) elapsed=    1816
Preprocess() elapsed=    2448
_resourceHandler->_statemachine->ControlThread::Cycle() elapsed=    2771


		/*	for(int i=0; i< workorders->size(); i++)
			{
				if(workorders->at(i)->CurrentStep()>=0)
				{
					tmp += StdStringFormat("%s(%d),",	workorders->at(i)->CurrentPartId().c_str(),workorders->at(i)->CurrentStep() );
				}
			}*/


			/*		for(int i=0; i< workorders->parts.size(); i++)
			{
				if(i>0) tmp+=',';
				tmp += StdStringFormat("%d",	workorders->finishedparts[workorders->parts[i]]);
			}*/



			// Get 0 program timing status for this part
			std::vector<ProgramTimingTuple>::iterator it = std::find_if(_programTuple.begin(), _programTuple.end(), 
				boost::bind(&ProgramTimingTuple::get<0>, _1) == pJob->_partid
				&&
				boost::bind(&ProgramTimingTuple::get<1>, _1) == pJob->_programs[0]);
			ProgramTimingTuple  ptt; 
			if(it == _programTuple.end())
				ptt =make_tuple(pJob->_partid, pJob->_programs[0], 0, 0, 0); 
			else
				ptt =make_tuple(pJob->_partid, pJob->_programs[0], get<2>(*it)+1, 0, 0); 

						//Part * part = Factory.FindPartById( workorder->_partid.c_str());
					//workorder->nStartGood;
					//workorder->nStartBad

#if 0
			workorder->factoryTime.Start();
			workorder->AssignCurrentResource(rh);
			workorder->bActive=true;
			workorder->_programs=workorder->GetPrograms( (LPCSTR) rh->_resource->identifier);  // resource name
			workorder->_estimatedTimes=workorder->GetEstimatedTimes( (LPCSTR) rh->_resource->identifier);
			workorder->_currentprog=-1; // redundant - done in constructor - but making explicitly clear
			rh->_statemachine->Push(workorder);  // start workorder
#endif

#else
			for(int k=0; k< cell->resourceIds.size(); k++)
			{


				CResourceHandler * rh = CResourceHandler::FindHandler((LPCSTR) cell->resourceIds[k]);// workorder->_CellResourcesRequired[0]->_ResourceHandlers[i]; 

				if( rh->_statemachine->CanPush()
					&& rh->_statemachine->GetStateName() != "faulted"
					)
				{ 
					workorder->CurrentStep()=0;
					workorder->factoryTime.Start();
					workorder->AssignCurrentResource(rh);
					workorder->bActive=true;
					workorder->_programs=workorder->GetPrograms((LPCSTR) cell->resourceIds[k], (LPCSTR) rh->_resource->identifier);  // resource name
					workorder->_estimatedTimes=workorder->GetEstimatedTimes((LPCSTR) cell->resourceIds[k], (LPCSTR) rh->_resource->identifier);
					workorder->_currentprog=-1; // redundant - done in constructor - but making explicitly clear
					rh->_statemachine->Push(workorder);  // start workorder

					workorder->_mttp=rh->_statemachine->MTTP;  // reset time to finish - new workorder
				}
			}
#endif

#if 0
				workorder->factoryTime.Start();
				workorder->AssignCurrentResource(resource1);
				workorder->bActive=true;
				workorder->_programs=workorder->GetPrograms( (LPCSTR) resource1->_resource->identifier);  // resource name
				workorder->_estimatedTimes=workorder->GetEstimatedTimes( (LPCSTR) resource1->_resource->identifier);
				workorder->_currentprog=-1; // redundant - done in constructor - but making explicitly clear
				resource1->_statemachine->Push(workorder);  // start workorder in next resoure
#endif
#else
				// Choose cell resource that is not busy
				int k;
				CResourceHandler *  resource1;
				for(k=0;  k< cell1->resourceIds.size(); k++)
				{
					resource1 = CResourceHandler::FindHandler((LPCSTR) cell1->resourceIds[k]);// workorder->_CellResourcesRequired[0]->_ResourceHandlers[i]; 
					//resource1 = cellHandler1->_ResourceHandlers[k] ; 
					if( resource1->_statemachine->CanPush() && resource1->_statemachine->GetStateName() != "faulted" )
						break;
				}
				if(k==cell1->resourceIds.size())
					continue;  // Could not find free cell resource -either blocked or full queue - FIXME: if r1Q>r2Q choose r2
				if(resource1==NULL)  // should break if probem
					DebugBreak();

				/* Pop workorder command from current resource and then increment current step, and push 
				workorder onto next resource command queue
				*/
				//CWorkOrder * workorder = resource->_statemachine->Pop();    // finished current step
				resource->_statemachine->Pop();    // finished current step
				workorder->CurrentStep()++; // incremeent current step
				resource1->_statemachine->Push(workorder);
				workorder->AssignCurrentResource(resource1);
				workorder->_programs=workorder->GetPrograms( (LPCSTR) resource1->_resource->identifier);  // resource name
				workorder->_estimatedTimes=workorder->GetEstimatedTimes((LPCSTR)resource1->_resource->identifier);
				workorder->_currentprog=-1; // redundant - done in constructor - but making explicitly clear
#endif